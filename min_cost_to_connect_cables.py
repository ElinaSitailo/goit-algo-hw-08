# T1. Уявіть, що вам на технічному інтерв'ю дають наступну задачу, яку треба розв'язати за допомогою купи.
# Є декілька мережевих кабелів різної довжини, їх потрібно об'єднати по два за раз в один кабель, використовуючи з'єднувачі,
# у порядку, який призведе до найменших витрат.
# Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин,
# а загальні витрати дорівнюють сумі з'єднання всіх кабелів.
# Завдання полягає в тому, щоб знайти порядок об'єднання, який мінімізує загальні витрати.

import heapq


def min_cost_to_connect_cables(cable_lengths):
    """Функція для обчислення мінімальних витрат на з'єднання кабелів."""

    heapq.heapify(cable_lengths)  # Перетворюємо список довжин кабелів у мін-купу
    total_cost = 0

    # Поки в купі більше одного кабелю
    while len(cable_lengths) > 1:
        # Витягуємо два найкоротші кабелі
        first = heapq.heappop(cable_lengths)
        second = heapq.heappop(cable_lengths)

        cost = first + second
        total_cost += cost
        print(f"З'єднуємо кабелі довжиною {first} і {second} (вартість {cost})")

        # Додаємо новий кабель назад у купу
        heapq.heappush(cable_lengths, cost)

    return total_cost


cables = [4, 3, 2, 6]
min_cost = min_cost_to_connect_cables(cables)
print(f"Мінімальні витрати на з'єднання кабелів : {min_cost}")
# Пояснення:
# Якщо спочатку з’єднати довгі кабелі, їхня велика довжина буде багато разів включена у витрати.
# А якщо довгі кабелі об’єднаються в кінці, вони додають свою вартість лише один раз.
